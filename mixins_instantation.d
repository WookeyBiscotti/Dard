// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/format/internal/write.d(1993,40)
(in ref int a) => a

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/variant.d(90,17)
T _field_0LU;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/variant.d(90,17)
T _field_1LU;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/variant.d(90,17)
T _field_2LU;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)


// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(219,13)
alias a = __a ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(220,13)
alias b = __b ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(221,20)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(449,16)
cast(T)a < cast(T) b

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/format/spec.d(170,13)
private ubyte _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf;@property bool flDash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 1U) != 0;}
@property void flDash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 1U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))1U);}
@property bool flZero() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 2U) != 0;}
@property void flZero(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 2U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))2U);}
@property bool flSpace() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 4U) != 0;}
@property void flSpace(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 4U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))4U);}
@property bool flPlus() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 8U) != 0;}
@property void flPlus(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 8U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))8U);}
@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}
@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}
@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}
@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}
@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}
@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(449,16)
cast(T)a < cast(T) b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(449,16)
cast(T)a < cast(T) b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(219,13)
alias a = __a ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(220,13)
alias b = __b ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(221,20)
a == b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(467,13)
enum int data = 0;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(467,13)
enum int count = 0;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias data = _0LU;alias _1LU = Identity!(field[1LU]);alias count = _1LU;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7015,17)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7032,21)

    case '\u0000':..case '\u0008':case '\u000E':..case '\u001F':case '\u007F':..
    case '\u0084':case '\u0086':..case '\u009F': case '\u0009':..case '\u000C': case '\u0085':

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7041,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7045,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7049,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7053,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7058,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7065,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7069,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7077,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7091,13)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7015,17)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7032,21)

    case '\u0000':..case '\u0008':case '\u000E':..case '\u001F':case '\u007F':..
    case '\u0084':case '\u0086':..case '\u009F': case '\u0009':..case '\u000C': case '\u0085':

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7041,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7045,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7049,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7053,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7058,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7065,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7069,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7077,21)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/uni/package.d(7091,13)

            static if (getValue)
                grapheme ~= ch;
            range.popFront();
        

// expansion at source/dard/base/entity.d(21,9)
@("buildin") typeof(scoped!C(Parameters!(C.__ctor).init)) _transform;

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/matrix.d(899,18)
T a11;T a21;T a12;T a22;

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; T z; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; T b; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; T p; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/matrix.d(899,18)
T a11;T a21;T a31;T a12;T a22;T a32;T a13;T a23;T a33;

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; T z; T w; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; T b; T a; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; T p; T q; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/matrix.d(899,18)
T a11;T a21;T a31;T a41;T a12;T a22;T a32;T a42;T a13;T a23;T a33;T a43;T a14;T a24;T a34;T a44;

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/matrix.d(899,18)
T a11;T a21;T a12;T a22;

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; T z; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; T b; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; T p; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/matrix.d(899,18)
T a11;T a21;T a31;T a12;T a22;T a32;T a13;T a23;T a33;

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; T z; T w; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; T b; T a; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; T p; T q; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/matrix.d(899,18)
T a11;T a21;T a31;T a41;T a12;T a22;T a32;T a42;T a13;T a23;T a33;T a43;T a14;T a24;T a34;T a44;

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; T z; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; T b; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; T p; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; T z; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; T b; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; T p; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; T z; T w; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; T b; T a; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; T p; T q; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(728,22)
T x; T y; T z; T w; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(731,22)
T r; T g; T b; T a; 

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/vector.d(734,22)
T s; T t; T p; T q; 

// expansion at source/dard/base/entity.d(23,9)
public ref auto transform() {return _transform;}

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/variant.d(90,17)
T _field_0LU;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/variant.d(90,17)
T _field_1LU;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/variant.d(90,17)
T _field_2LU;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/variant.d(90,17)
T _field_3LU;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/variant.d(90,17)
T _field_4LU;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(464,1)
alias BGFX_FATAL_DEBUGCHECK = bgfx_fatal_t.BGFX_FATAL_DEBUGCHECK;alias BGFX_FATAL_INVALIDSHADER = bgfx_fatal_t.BGFX_FATAL_INVALIDSHADER;alias BGFX_FATAL_UNABLETOINITIALIZE = bgfx_fatal_t.BGFX_FATAL_UNABLETOINITIALIZE;alias BGFX_FATAL_UNABLETOCREATETEXTURE = bgfx_fatal_t.BGFX_FATAL_UNABLETOCREATETEXTURE;alias BGFX_FATAL_DEVICELOST = bgfx_fatal_t.BGFX_FATAL_DEVICELOST;alias BGFX_FATAL_COUNT = bgfx_fatal_t.BGFX_FATAL_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(484,1)
alias BGFX_RENDERER_TYPE_NOOP = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_NOOP;alias BGFX_RENDERER_TYPE_AGC = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_AGC;alias BGFX_RENDERER_TYPE_DIRECT3D9 = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_DIRECT3D9;alias BGFX_RENDERER_TYPE_DIRECT3D11 = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_DIRECT3D11;alias BGFX_RENDERER_TYPE_DIRECT3D12 = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_DIRECT3D12;alias BGFX_RENDERER_TYPE_GNM = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_GNM;alias BGFX_RENDERER_TYPE_METAL = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_METAL;alias BGFX_RENDERER_TYPE_NVN = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_NVN;alias BGFX_RENDERER_TYPE_OPENGLES = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_OPENGLES;alias BGFX_RENDERER_TYPE_OPENGL = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_OPENGL;alias BGFX_RENDERER_TYPE_VULKAN = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_VULKAN;alias BGFX_RENDERER_TYPE_WEBGPU = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_WEBGPU;alias BGFX_RENDERER_TYPE_COUNT = bgfx_renderer_type_t.BGFX_RENDERER_TYPE_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(495,1)
alias BGFX_ACCESS_READ = bgfx_access_t.BGFX_ACCESS_READ;alias BGFX_ACCESS_WRITE = bgfx_access_t.BGFX_ACCESS_WRITE;alias BGFX_ACCESS_READWRITE = bgfx_access_t.BGFX_ACCESS_READWRITE;alias BGFX_ACCESS_COUNT = bgfx_access_t.BGFX_ACCESS_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(521,1)
alias BGFX_ATTRIB_POSITION = bgfx_attrib_t.BGFX_ATTRIB_POSITION;alias BGFX_ATTRIB_NORMAL = bgfx_attrib_t.BGFX_ATTRIB_NORMAL;alias BGFX_ATTRIB_TANGENT = bgfx_attrib_t.BGFX_ATTRIB_TANGENT;alias BGFX_ATTRIB_BITANGENT = bgfx_attrib_t.BGFX_ATTRIB_BITANGENT;alias BGFX_ATTRIB_COLOR0 = bgfx_attrib_t.BGFX_ATTRIB_COLOR0;alias BGFX_ATTRIB_COLOR1 = bgfx_attrib_t.BGFX_ATTRIB_COLOR1;alias BGFX_ATTRIB_COLOR2 = bgfx_attrib_t.BGFX_ATTRIB_COLOR2;alias BGFX_ATTRIB_COLOR3 = bgfx_attrib_t.BGFX_ATTRIB_COLOR3;alias BGFX_ATTRIB_INDICES = bgfx_attrib_t.BGFX_ATTRIB_INDICES;alias BGFX_ATTRIB_WEIGHT = bgfx_attrib_t.BGFX_ATTRIB_WEIGHT;alias BGFX_ATTRIB_TEXCOORD0 = bgfx_attrib_t.BGFX_ATTRIB_TEXCOORD0;alias BGFX_ATTRIB_TEXCOORD1 = bgfx_attrib_t.BGFX_ATTRIB_TEXCOORD1;alias BGFX_ATTRIB_TEXCOORD2 = bgfx_attrib_t.BGFX_ATTRIB_TEXCOORD2;alias BGFX_ATTRIB_TEXCOORD3 = bgfx_attrib_t.BGFX_ATTRIB_TEXCOORD3;alias BGFX_ATTRIB_TEXCOORD4 = bgfx_attrib_t.BGFX_ATTRIB_TEXCOORD4;alias BGFX_ATTRIB_TEXCOORD5 = bgfx_attrib_t.BGFX_ATTRIB_TEXCOORD5;alias BGFX_ATTRIB_TEXCOORD6 = bgfx_attrib_t.BGFX_ATTRIB_TEXCOORD6;alias BGFX_ATTRIB_TEXCOORD7 = bgfx_attrib_t.BGFX_ATTRIB_TEXCOORD7;alias BGFX_ATTRIB_COUNT = bgfx_attrib_t.BGFX_ATTRIB_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(534,1)
alias BGFX_ATTRIB_TYPE_UINT8 = bgfx_attrib_type_t.BGFX_ATTRIB_TYPE_UINT8;alias BGFX_ATTRIB_TYPE_UINT10 = bgfx_attrib_type_t.BGFX_ATTRIB_TYPE_UINT10;alias BGFX_ATTRIB_TYPE_INT16 = bgfx_attrib_type_t.BGFX_ATTRIB_TYPE_INT16;alias BGFX_ATTRIB_TYPE_HALF = bgfx_attrib_type_t.BGFX_ATTRIB_TYPE_HALF;alias BGFX_ATTRIB_TYPE_FLOAT = bgfx_attrib_type_t.BGFX_ATTRIB_TYPE_FLOAT;alias BGFX_ATTRIB_TYPE_COUNT = bgfx_attrib_type_t.BGFX_ATTRIB_TYPE_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(651,1)
alias BGFX_TEXTURE_FORMAT_BC1 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_BC1;alias BGFX_TEXTURE_FORMAT_BC2 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_BC2;alias BGFX_TEXTURE_FORMAT_BC3 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_BC3;alias BGFX_TEXTURE_FORMAT_BC4 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_BC4;alias BGFX_TEXTURE_FORMAT_BC5 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_BC5;alias BGFX_TEXTURE_FORMAT_BC6H = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_BC6H;alias BGFX_TEXTURE_FORMAT_BC7 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_BC7;alias BGFX_TEXTURE_FORMAT_ETC1 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ETC1;alias BGFX_TEXTURE_FORMAT_ETC2 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ETC2;alias BGFX_TEXTURE_FORMAT_ETC2A = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ETC2A;alias BGFX_TEXTURE_FORMAT_ETC2A1 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ETC2A1;alias BGFX_TEXTURE_FORMAT_PTC12 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_PTC12;alias BGFX_TEXTURE_FORMAT_PTC14 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_PTC14;alias BGFX_TEXTURE_FORMAT_PTC12A = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_PTC12A;alias BGFX_TEXTURE_FORMAT_PTC14A = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_PTC14A;alias BGFX_TEXTURE_FORMAT_PTC22 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_PTC22;alias BGFX_TEXTURE_FORMAT_PTC24 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_PTC24;alias BGFX_TEXTURE_FORMAT_ATC = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ATC;alias BGFX_TEXTURE_FORMAT_ATCE = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ATCE;alias BGFX_TEXTURE_FORMAT_ATCI = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ATCI;alias BGFX_TEXTURE_FORMAT_ASTC4X4 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC4X4;alias BGFX_TEXTURE_FORMAT_ASTC5X4 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC5X4;alias BGFX_TEXTURE_FORMAT_ASTC5X5 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC5X5;alias BGFX_TEXTURE_FORMAT_ASTC6X5 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC6X5;alias BGFX_TEXTURE_FORMAT_ASTC6X6 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC6X6;alias BGFX_TEXTURE_FORMAT_ASTC8X5 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC8X5;alias BGFX_TEXTURE_FORMAT_ASTC8X6 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC8X6;alias BGFX_TEXTURE_FORMAT_ASTC8X8 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC8X8;alias BGFX_TEXTURE_FORMAT_ASTC10X5 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC10X5;alias BGFX_TEXTURE_FORMAT_ASTC10X6 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC10X6;alias BGFX_TEXTURE_FORMAT_ASTC10X8 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC10X8;alias BGFX_TEXTURE_FORMAT_ASTC10X10 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC10X10;alias BGFX_TEXTURE_FORMAT_ASTC12X10 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC12X10;alias BGFX_TEXTURE_FORMAT_ASTC12X12 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_ASTC12X12;alias BGFX_TEXTURE_FORMAT_UNKNOWN = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_UNKNOWN;alias BGFX_TEXTURE_FORMAT_R1 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R1;alias BGFX_TEXTURE_FORMAT_A8 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_A8;alias BGFX_TEXTURE_FORMAT_R8 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R8;alias BGFX_TEXTURE_FORMAT_R8I = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R8I;alias BGFX_TEXTURE_FORMAT_R8U = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R8U;alias BGFX_TEXTURE_FORMAT_R8S = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R8S;alias BGFX_TEXTURE_FORMAT_R16 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R16;alias BGFX_TEXTURE_FORMAT_R16I = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R16I;alias BGFX_TEXTURE_FORMAT_R16U = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R16U;alias BGFX_TEXTURE_FORMAT_R16F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R16F;alias BGFX_TEXTURE_FORMAT_R16S = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R16S;alias BGFX_TEXTURE_FORMAT_R32I = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R32I;alias BGFX_TEXTURE_FORMAT_R32U = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R32U;alias BGFX_TEXTURE_FORMAT_R32F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R32F;alias BGFX_TEXTURE_FORMAT_RG8 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG8;alias BGFX_TEXTURE_FORMAT_RG8I = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG8I;alias BGFX_TEXTURE_FORMAT_RG8U = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG8U;alias BGFX_TEXTURE_FORMAT_RG8S = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG8S;alias BGFX_TEXTURE_FORMAT_RG16 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG16;alias BGFX_TEXTURE_FORMAT_RG16I = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG16I;alias BGFX_TEXTURE_FORMAT_RG16U = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG16U;alias BGFX_TEXTURE_FORMAT_RG16F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG16F;alias BGFX_TEXTURE_FORMAT_RG16S = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG16S;alias BGFX_TEXTURE_FORMAT_RG32I = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG32I;alias BGFX_TEXTURE_FORMAT_RG32U = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG32U;alias BGFX_TEXTURE_FORMAT_RG32F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG32F;alias BGFX_TEXTURE_FORMAT_RGB8 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGB8;alias BGFX_TEXTURE_FORMAT_RGB8I = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGB8I;alias BGFX_TEXTURE_FORMAT_RGB8U = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGB8U;alias BGFX_TEXTURE_FORMAT_RGB8S = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGB8S;alias BGFX_TEXTURE_FORMAT_RGB9E5F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGB9E5F;alias BGFX_TEXTURE_FORMAT_BGRA8 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_BGRA8;alias BGFX_TEXTURE_FORMAT_RGBA8 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA8;alias BGFX_TEXTURE_FORMAT_RGBA8I = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA8I;alias BGFX_TEXTURE_FORMAT_RGBA8U = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA8U;alias BGFX_TEXTURE_FORMAT_RGBA8S = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA8S;alias BGFX_TEXTURE_FORMAT_RGBA16 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA16;alias BGFX_TEXTURE_FORMAT_RGBA16I = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA16I;alias BGFX_TEXTURE_FORMAT_RGBA16U = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA16U;alias BGFX_TEXTURE_FORMAT_RGBA16F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA16F;alias BGFX_TEXTURE_FORMAT_RGBA16S = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA16S;alias BGFX_TEXTURE_FORMAT_RGBA32I = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA32I;alias BGFX_TEXTURE_FORMAT_RGBA32U = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA32U;alias BGFX_TEXTURE_FORMAT_RGBA32F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA32F;alias BGFX_TEXTURE_FORMAT_B5G6R5 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_B5G6R5;alias BGFX_TEXTURE_FORMAT_R5G6B5 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_R5G6B5;alias BGFX_TEXTURE_FORMAT_BGRA4 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_BGRA4;alias BGFX_TEXTURE_FORMAT_RGBA4 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGBA4;alias BGFX_TEXTURE_FORMAT_BGR5A1 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_BGR5A1;alias BGFX_TEXTURE_FORMAT_RGB5A1 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGB5A1;alias BGFX_TEXTURE_FORMAT_RGB10A2 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RGB10A2;alias BGFX_TEXTURE_FORMAT_RG11B10F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_RG11B10F;alias BGFX_TEXTURE_FORMAT_UNKNOWNDEPTH = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_UNKNOWNDEPTH;alias BGFX_TEXTURE_FORMAT_D16 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_D16;alias BGFX_TEXTURE_FORMAT_D24 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_D24;alias BGFX_TEXTURE_FORMAT_D24S8 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_D24S8;alias BGFX_TEXTURE_FORMAT_D32 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_D32;alias BGFX_TEXTURE_FORMAT_D16F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_D16F;alias BGFX_TEXTURE_FORMAT_D24F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_D24F;alias BGFX_TEXTURE_FORMAT_D32F = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_D32F;alias BGFX_TEXTURE_FORMAT_D0S8 = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_D0S8;alias BGFX_TEXTURE_FORMAT_COUNT = bgfx_texture_format_t.BGFX_TEXTURE_FORMAT_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(664,1)
alias BGFX_UNIFORM_TYPE_SAMPLER = bgfx_uniform_type_t.BGFX_UNIFORM_TYPE_SAMPLER;alias BGFX_UNIFORM_TYPE_END = bgfx_uniform_type_t.BGFX_UNIFORM_TYPE_END;alias BGFX_UNIFORM_TYPE_VEC4 = bgfx_uniform_type_t.BGFX_UNIFORM_TYPE_VEC4;alias BGFX_UNIFORM_TYPE_MAT3 = bgfx_uniform_type_t.BGFX_UNIFORM_TYPE_MAT3;alias BGFX_UNIFORM_TYPE_MAT4 = bgfx_uniform_type_t.BGFX_UNIFORM_TYPE_MAT4;alias BGFX_UNIFORM_TYPE_COUNT = bgfx_uniform_type_t.BGFX_UNIFORM_TYPE_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(678,1)
alias BGFX_BACKBUFFER_RATIO_EQUAL = bgfx_backbuffer_ratio_t.BGFX_BACKBUFFER_RATIO_EQUAL;alias BGFX_BACKBUFFER_RATIO_HALF = bgfx_backbuffer_ratio_t.BGFX_BACKBUFFER_RATIO_HALF;alias BGFX_BACKBUFFER_RATIO_QUARTER = bgfx_backbuffer_ratio_t.BGFX_BACKBUFFER_RATIO_QUARTER;alias BGFX_BACKBUFFER_RATIO_EIGHTH = bgfx_backbuffer_ratio_t.BGFX_BACKBUFFER_RATIO_EIGHTH;alias BGFX_BACKBUFFER_RATIO_SIXTEENTH = bgfx_backbuffer_ratio_t.BGFX_BACKBUFFER_RATIO_SIXTEENTH;alias BGFX_BACKBUFFER_RATIO_DOUBLE = bgfx_backbuffer_ratio_t.BGFX_BACKBUFFER_RATIO_DOUBLE;alias BGFX_BACKBUFFER_RATIO_COUNT = bgfx_backbuffer_ratio_t.BGFX_BACKBUFFER_RATIO_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(689,1)
alias BGFX_OCCLUSION_QUERY_RESULT_INVISIBLE = bgfx_occlusion_query_result_t.BGFX_OCCLUSION_QUERY_RESULT_INVISIBLE;alias BGFX_OCCLUSION_QUERY_RESULT_VISIBLE = bgfx_occlusion_query_result_t.BGFX_OCCLUSION_QUERY_RESULT_VISIBLE;alias BGFX_OCCLUSION_QUERY_RESULT_NORESULT = bgfx_occlusion_query_result_t.BGFX_OCCLUSION_QUERY_RESULT_NORESULT;alias BGFX_OCCLUSION_QUERY_RESULT_COUNT = bgfx_occlusion_query_result_t.BGFX_OCCLUSION_QUERY_RESULT_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(702,1)
alias BGFX_TOPOLOGY_TRILIST = bgfx_topology_t.BGFX_TOPOLOGY_TRILIST;alias BGFX_TOPOLOGY_TRISTRIP = bgfx_topology_t.BGFX_TOPOLOGY_TRISTRIP;alias BGFX_TOPOLOGY_LINELIST = bgfx_topology_t.BGFX_TOPOLOGY_LINELIST;alias BGFX_TOPOLOGY_LINESTRIP = bgfx_topology_t.BGFX_TOPOLOGY_LINESTRIP;alias BGFX_TOPOLOGY_POINTLIST = bgfx_topology_t.BGFX_TOPOLOGY_POINTLIST;alias BGFX_TOPOLOGY_COUNT = bgfx_topology_t.BGFX_TOPOLOGY_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(715,1)
alias BGFX_TOPOLOGY_CONVERT_TRILISTFLIPWINDING = bgfx_topology_convert_t.BGFX_TOPOLOGY_CONVERT_TRILISTFLIPWINDING;alias BGFX_TOPOLOGY_CONVERT_TRISTRIPFLIPWINDING = bgfx_topology_convert_t.BGFX_TOPOLOGY_CONVERT_TRISTRIPFLIPWINDING;alias BGFX_TOPOLOGY_CONVERT_TRILISTTOLINELIST = bgfx_topology_convert_t.BGFX_TOPOLOGY_CONVERT_TRILISTTOLINELIST;alias BGFX_TOPOLOGY_CONVERT_TRISTRIPTOTRILIST = bgfx_topology_convert_t.BGFX_TOPOLOGY_CONVERT_TRISTRIPTOTRILIST;alias BGFX_TOPOLOGY_CONVERT_LINESTRIPTOLINELIST = bgfx_topology_convert_t.BGFX_TOPOLOGY_CONVERT_LINESTRIPTOLINELIST;alias BGFX_TOPOLOGY_CONVERT_COUNT = bgfx_topology_convert_t.BGFX_TOPOLOGY_CONVERT_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(735,1)
alias BGFX_TOPOLOGY_SORT_DIRECTIONFRONTTOBACKMIN = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DIRECTIONFRONTTOBACKMIN;alias BGFX_TOPOLOGY_SORT_DIRECTIONFRONTTOBACKAVG = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DIRECTIONFRONTTOBACKAVG;alias BGFX_TOPOLOGY_SORT_DIRECTIONFRONTTOBACKMAX = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DIRECTIONFRONTTOBACKMAX;alias BGFX_TOPOLOGY_SORT_DIRECTIONBACKTOFRONTMIN = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DIRECTIONBACKTOFRONTMIN;alias BGFX_TOPOLOGY_SORT_DIRECTIONBACKTOFRONTAVG = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DIRECTIONBACKTOFRONTAVG;alias BGFX_TOPOLOGY_SORT_DIRECTIONBACKTOFRONTMAX = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DIRECTIONBACKTOFRONTMAX;alias BGFX_TOPOLOGY_SORT_DISTANCEFRONTTOBACKMIN = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DISTANCEFRONTTOBACKMIN;alias BGFX_TOPOLOGY_SORT_DISTANCEFRONTTOBACKAVG = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DISTANCEFRONTTOBACKAVG;alias BGFX_TOPOLOGY_SORT_DISTANCEFRONTTOBACKMAX = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DISTANCEFRONTTOBACKMAX;alias BGFX_TOPOLOGY_SORT_DISTANCEBACKTOFRONTMIN = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DISTANCEBACKTOFRONTMIN;alias BGFX_TOPOLOGY_SORT_DISTANCEBACKTOFRONTAVG = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DISTANCEBACKTOFRONTAVG;alias BGFX_TOPOLOGY_SORT_DISTANCEBACKTOFRONTMAX = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_DISTANCEBACKTOFRONTMAX;alias BGFX_TOPOLOGY_SORT_COUNT = bgfx_topology_sort_t.BGFX_TOPOLOGY_SORT_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(747,1)
alias BGFX_VIEW_MODE_DEFAULT = bgfx_view_mode_t.BGFX_VIEW_MODE_DEFAULT;alias BGFX_VIEW_MODE_SEQUENTIAL = bgfx_view_mode_t.BGFX_VIEW_MODE_SEQUENTIAL;alias BGFX_VIEW_MODE_DEPTHASCENDING = bgfx_view_mode_t.BGFX_VIEW_MODE_DEPTHASCENDING;alias BGFX_VIEW_MODE_DEPTHDESCENDING = bgfx_view_mode_t.BGFX_VIEW_MODE_DEPTHDESCENDING;alias BGFX_VIEW_MODE_COUNT = bgfx_view_mode_t.BGFX_VIEW_MODE_COUNT;

// expansion at ../../.dub/packages/bindbc-bgfx/0.8.0+118/bindbc-bgfx/source/bindbc/bgfx/types.d(759,1)
alias BGFX_RENDER_FRAME_NOCONTEXT = bgfx_render_frame_t.BGFX_RENDER_FRAME_NOCONTEXT;alias BGFX_RENDER_FRAME_RENDER = bgfx_render_frame_t.BGFX_RENDER_FRAME_RENDER;alias BGFX_RENDER_FRAME_TIMEOUT = bgfx_render_frame_t.BGFX_RENDER_FRAME_TIMEOUT;alias BGFX_RENDER_FRAME_EXITING = bgfx_render_frame_t.BGFX_RENDER_FRAME_EXITING;alias BGFX_RENDER_FRAME_COUNT = bgfx_render_frame_t.BGFX_RENDER_FRAME_COUNT;

// expansion at source/dard/systems/asset/asset.d(58,9)
private HashMap!(String, RC!T, true) _fonts;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/dard/systems/asset/asset.d(58,9)
private HashMap!(String, RC!T, true) _meshes;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/dard/systems/asset/asset.d(58,9)
private HashMap!(String, RC!T, true) _shadersFS;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/dard/systems/asset/asset.d(58,9)
private HashMap!(String, RC!T, true) _shadersVS;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/dard/systems/asset/asset.d(58,9)
private HashMap!(String, RC!T, true) _programs;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/dard/systems/asset/asset.d(58,9)
private HashMap!(String, RC!T, true) _materials;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/dard/systems/asset/asset.d(58,9)
private HashMap!(String, RC!T, true) _object3ds;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(300,13)
enum memberName = `values_0`;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(305,13)
T values_0;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(300,13)
enum memberName = `values_1`;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(305,13)
T values_1;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(300,13)
enum memberName = `values_2`;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(305,13)
T values_2;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(300,13)
enum memberName = `values_3`;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(305,13)
T values_3;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(300,13)
enum memberName = `values_4`;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(305,13)
T values_4;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(543,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(551,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(551,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(551,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(551,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/time.d(2354,9)
_ticks += rhsConverted;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a > b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a > b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a > b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a > b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(551,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(551,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/dard/systems/asset/asset.d(62,30)
_shadersVS

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);alias _2LU = Identity!(field[2LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/dard/systems/asset/asset.d(83,30)
_shadersVS

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);alias _2LU = Identity!(field[2LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(551,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(543,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/dard/systems/asset/asset.d(62,30)
_shadersFS

// expansion at source/dard/systems/asset/asset.d(83,30)
_shadersFS

// expansion at source/dard/systems/asset/asset.d(62,30)
_meshes

// expansion at source/dard/systems/asset/asset.d(83,30)
_meshes

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/dard/systems/asset/asset.d(112,30)
_materials

// expansion at source/dard/systems/asset/asset.d(106,30)
_materials

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/traits.d(93,9)
alias substInout = substInoutForm!U;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(467,13)
enum int schema = 0;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(467,13)
enum int sequence = 0;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias schema = _0LU;alias _1LU = Identity!(field[1LU]);alias sequence = _1LU;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/internal/memory.d(32,18)
onOutOfMemoryError();

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(219,13)
alias a = __a ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(220,13)
alias b = __b ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(221,20)
a == b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(219,13)
alias a = __a ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(220,13)
alias b = __b ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(221,20)
a == b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(449,16)
cast(T)a < cast(T) b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/traits.d(93,9)
alias substInout = substInoutForm!U;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/traits.d(93,9)
alias substInout = substInoutForm!U;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(219,13)
alias a = __a ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(220,13)
alias b = __b ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(221,20)
a == b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(219,13)
alias a = __a ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(220,13)
alias b = __b ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(221,20)
a == b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(219,13)
alias a = __a ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(220,13)
alias b = __b ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(221,20)
a == b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(219,13)
alias a = __a ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(220,13)
alias b = __b ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(221,20)
a == b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(219,13)
alias a = __a ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(220,13)
alias b = __b ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(221,20)
a == b

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(646,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/time.d(944,9)
return Duration(_hnsecs / value);

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/time.d(697,29)
_hnsecs - rhs._hnsecs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/atomic.d(576,9)
*cast(T*)&val+=mod

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/stdio.d(5303,38)
core.stdc.stdio.stdin

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/atomic.d(576,9)
*cast(T*)&val+=mod

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/atomic.d(576,9)
*cast(T*)&val-=mod

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/atomic.d(576,9)
*cast(T*)&val+=mod

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/stdio.d(5303,38)
core.stdc.stdio.stdout

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/atomic.d(576,9)
*cast(T*)&val+=mod

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/atomic.d(576,9)
*cast(T*)&val-=mod

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/atomic.d(576,9)
*cast(T*)&val+=mod

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/stdio.d(5303,38)
core.stdc.stdio.stderr

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/atomic.d(576,9)
*cast(T*)&val+=mod

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/atomic.d(576,9)
*cast(T*)&val-=mod

// expansion at source/dard/systems/asset/asset.d(62,30)
_programs

// expansion at source/dard/systems/asset/asset.d(83,30)
_programs

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a < b

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(219,13)
alias a = __a ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(220,13)
alias b = __b ;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(221,20)
a == b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2000,13)
alias handler0 = handler;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(641,21)
Storage newStorage = { values_0: __ctfe ? rhs : forward!rhs };

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(641,21)
Storage newStorage = { values_1: __ctfe ? rhs : forward!rhs };

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(641,21)
Storage newStorage = { values_2: __ctfe ? rhs : forward!rhs };

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(641,21)
Storage newStorage = { values_3: __ctfe ? rhs : forward!rhs };

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(641,21)
Storage newStorage = { values_4: __ctfe ? rhs : forward!rhs };

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2000,13)
alias handler0 = handler;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2000,13)
alias handler0 = handler;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(543,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2000,13)
alias handler0 = handler;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2000,13)
alias handler0 = handler;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), args[1].get!(SumTypes[1].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), args[1].get!(SumTypes[1].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), args[1].get!(SumTypes[1].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), args[1].get!(SumTypes[1].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), args[1].get!(SumTypes[1].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), args[1].get!(SumTypes[1].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), args[1].get!(SumTypes[1].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), args[1].get!(SumTypes[1].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), args[1].get!(SumTypes[1].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), args[1].get!(SumTypes[1].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), args[1].get!(SumTypes[1].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), args[1].get!(SumTypes[1].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), args[1].get!(SumTypes[1].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), args[1].get!(SumTypes[1].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), args[1].get!(SumTypes[1].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), args[1].get!(SumTypes[1].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), args[1].get!(SumTypes[1].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), args[1].get!(SumTypes[1].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), args[1].get!(SumTypes[1].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), args[1].get!(SumTypes[1].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), args[1].get!(SumTypes[1].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), args[1].get!(SumTypes[1].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), args[1].get!(SumTypes[1].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), args[1].get!(SumTypes[1].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), args[1].get!(SumTypes[1].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2000,13)
alias handler0 = handler;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), args[1].get!(SumTypes[1].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), args[1].get!(SumTypes[1].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), args[1].get!(SumTypes[1].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), args[1].get!(SumTypes[1].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), args[1].get!(SumTypes[1].Types[0])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), args[1].get!(SumTypes[1].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), args[1].get!(SumTypes[1].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), args[1].get!(SumTypes[1].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), args[1].get!(SumTypes[1].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), args[1].get!(SumTypes[1].Types[1])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), args[1].get!(SumTypes[1].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), args[1].get!(SumTypes[1].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), args[1].get!(SumTypes[1].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), args[1].get!(SumTypes[1].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), args[1].get!(SumTypes[1].Types[2])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), args[1].get!(SumTypes[1].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), args[1].get!(SumTypes[1].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), args[1].get!(SumTypes[1].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), args[1].get!(SumTypes[1].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), args[1].get!(SumTypes[1].Types[3])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[0])(), args[1].get!(SumTypes[1].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[1])(), args[1].get!(SumTypes[1].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[2])(), args[1].get!(SumTypes[1].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[3])(), args[1].get!(SumTypes[1].Types[4])(), )

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/sumtype.d(2012,32)
handler0(args[0].get!(SumTypes[0].Types[4])(), args[1].get!(SumTypes[1].Types[4])(), )

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a < b

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ../../.dub/packages/automem/0.6.9/automem/source/automem/vector.d(211,13)
throw boundsException;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ../../.dub/packages/automem/0.6.9/automem/source/automem/vector.d(211,13)
throw boundsException;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ../../.dub/packages/automem/0.6.9/automem/source/automem/vector.d(211,13)
throw boundsException;

// expansion at ../../.dub/packages/automem/0.6.9/automem/source/automem/vector.d(387,17)
throw boundsException;

// expansion at ../../.dub/packages/automem/0.6.9/automem/source/automem/vector.d(390,17)
throw boundsException;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/matrix.d(699,21)
{
                auto m3inv = matrix4x4to3x3(this).inverse;
                res = matrix3x3to4x4(m3inv);
                Vector!(T,3) t = -(getColumn(3).xyz * m3inv);
                res.setColumn(3, Vector!(T,4)(t.x, t.y, t.z, 1.0f));
            }

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/matrix.d(701,21)
{
                Matrix!(T,N) l, u, p;
                decomposeLUP(this, l, u, p);
                foreach(j; 0..N)
                {
                    Vector!(T,N) b = p.getColumn(j);
                    Vector!(T,N) x;
                    solveLU(l, u, x, b);
                    res.setColumn(j, x);
                }
            }

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/matrix.d(699,21)
{
                auto m3inv = matrix4x4to3x3(this).inverse;
                res = matrix3x3to4x4(m3inv);
                Vector!(T,3) t = -(getColumn(3).xyz * m3inv);
                res.setColumn(3, Vector!(T,4)(t.x, t.y, t.z, 1.0f));
            }

// expansion at ../../.dub/packages/dlib/1.2.0/dlib/dlib/math/matrix.d(701,21)
{
                Matrix!(T,N) l, u, p;
                decomposeLUP(this, l, u, p);
                foreach(j; 0..N)
                {
                    Vector!(T,N) b = p.getColumn(j);
                    Vector!(T,N) x;
                    solveLU(l, u, x, b);
                    res.setColumn(j, x);
                }
            }

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a > b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a > b

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a > b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a > b

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a > b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a > b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a < b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(475,37)
a > b

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/functional.d(478,32)
a > b

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/core/internal/hash.d(551,5)

    enum bool isChained = is(typeof(seed) : size_t);
    static if (!isChained) enum size_t seed = 0;
    static if (hasCallableToHash!(typeof(val))) //CTFE depends on toHash()
    {
        static if (!__traits(isSame, typeof(val), __traits(parent, val.toHash))
            && is(typeof(val is null)))
        {
            static if (isChained)
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))), seed);
            else
                return hashOf(__traits(getMember, val, __traits(getAliasThis, typeof(val))));
        }
        else
        {
            static if (isChained)
                return hashOf(cast(size_t) val.toHash(), seed);
            else
                return val.toHash();
        }
    }
    else
    {
        import core.internal.convert : toUbyte;
        static if (__traits(hasMember, T, "toHash") && is(typeof(T.toHash) == function))
        {
            // TODO: in the future maybe this should be changed to a static
            // assert(0), because if there's a `toHash` the programmer probably
            // expected it to be called and a compilation failure here will
            // expose a bug in his code.
            //   In the future we also might want to disallow non-const toHash
            // altogether.
            pragma(msg, "Warning: struct "~__traits(identifier, T)
                ~" has method toHash, however it cannot be called with "
                ~typeof(val).stringof~" this.");
            static if (__traits(compiles, __traits(getLocation, T.toHash)))
            {
                enum file = __traits(getLocation, T.toHash)[0];
                enum line = __traits(getLocation, T.toHash)[1].stringof;
                pragma(msg, "  ",__traits(identifier, T),".toHash defined here: ",file,"(",line,")");
            }
        }

        static if (T.tupleof.length == 0)
        {
            return seed;
        }
        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)
        {
            static if (isChained) size_t h = seed;
            static foreach (i, F; typeof(val.tupleof))
            {
                static if (__traits(isStaticArray, F))
                {
                    static if (i == 0 && !isChained) size_t h = 0;
                    static if (F.sizeof > 0 && canBitwiseHash!F)
                        // May use smallBytesHash instead of bytesHash.
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    else
                        // We can avoid the "double hashing" the top-level version uses
                        // for consistency with TypeInfo.getHash.
                        foreach (ref e; val.tupleof[i])
                            h = hashOf(e, h);
                }
                else static if (is(F == struct) || is(F == union))
                {
                    static if (hasCallableToHash!F)
                    {
                        static if (!__traits(isSame, F, __traits(parent, val.tupleof[i].toHash))
                            && is(typeof(val.tupleof[i] is null)))
                        {
                            static if (i == 0 && !isChained)
                                size_t h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)));
                            else
                                h = hashOf(__traits(getMember, val.tupleof[i], __traits(getAliasThis, F)), h);
                        }
                        else
                        {
                            static if (i == 0 && !isChained)
                                size_t h = val.tupleof[i].toHash();
                            else
                                h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);
                        }
                    }
                    else static if (F.tupleof.length == 1)
                    {
                        // Handle the single member case separately to avoid unnecessarily using bytesHash.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i].tupleof[0]);
                        else
                            h = hashOf(val.tupleof[i].tupleof[0], h);
                    }
                    else static if (canBitwiseHash!F)
                    {
                        // May use smallBytesHash instead of bytesHash.
                        static if (i == 0 && !isChained) size_t h = 0;
                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);
                    }
                    else
                    {
                        // Nothing special happening.
                        static if (i == 0 && !isChained)
                            size_t h = hashOf(val.tupleof[i]);
                        else
                            h = hashOf(val.tupleof[i], h);
                    }
                }
                else
                {
                    // Nothing special happening.
                    static if (i == 0 && !isChained)
                        size_t h = hashOf(val.tupleof[i]);
                    else
                        h = hashOf(val.tupleof[i], h);
                }
            }
            return h;
        }
        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields
        {
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(toUbyte(val), seed);
        }
        else // CTFE unsupported
        {
            assert(!__ctfe, "unable to compute hash of "~T.stringof~" at compile time");
            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();
            // Not using bytesHashWithExactSizeAndAlignment here because
            // the result may differ from typeid(T).hashOf(&val).
            return bytesHashAlignedBy!T(bytes, seed);
        }
    }

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs == rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

// expansion at /home/alex/.local/share/code-d/bin/compilers/ldc-1.32.0/bin/../import/std/typecons.d(539,31)
lhs < rhs

